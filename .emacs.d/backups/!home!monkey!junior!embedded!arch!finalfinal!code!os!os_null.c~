/*************************
*file:os_null.c
*description:
*      final project
*author:
*    #郑培基
*    #郑远航
*    #赵国亮
*    #郑浩
*    #李铭瑶
*date:2012-12-9
*update:2012-12-29
*************************/

//types
typedef unsigned char uchar;
typedef unsigned short int ushort;

//for 数码管
#define LED_CS1   	(*((volatile ushort *)(0x10200000)))	//LED1 and LED2
#define LED_CS2   	(*((volatile ushort *)(0x10300000)))	//LED3 and LED4
#define LED_CS3   	(*((volatile ushort *)(0x10400000)))	//LED5 and LED6

//for led
#define LED_CS4		(*((volatile unsigned char *)(0x10500000)))

//for keyboard
#define KPDK_VALUE	(*((volatile unsigned char *)(0x41500008)))		//Direct Keypad
#define KPAS_VALUE  (*((volatile unsigned char *)(0x41500020)))		//Matrix Keypad

//for step motor
#define GPSR2   	(*((volatile unsigned int *)(0x40E00020)))
#define GPCR2   	(*((volatile unsigned int *)(0x40E0002C)))
#define GPDR2		(*((volatile unsigned int *)(0x40E00014)))
#define GPDR1		(*((volatile unsigned int *)(0x40E00010)))
#define GPLR2		(*((volatile unsigned int *)(0x40E00008)))

//const
#define LED_FLASH_TIMES 3
#define MAXF 5

//global variables
uchar currentLocation;
uchar led;
uchar state[MAXF+1];
short direction;
int next;        //next destination
int nextnext;    //next and next destination
int nnn[MAXF];   //array to store next destination
int len;        //the current len of the array nnn
int cur;        //the current index of the array nnn


//extern variables
extern void disable_lcd(void);
extern void enable_lcd(void);
extern void lighton1(void);
extern void lighton2(void);
extern void lightoff1(void);
extern void lightoff2(void);
extern void typename_Image1(void);
extern void typename_Image2(void);
extern void screen_clean(int);


//functions
void init(void);
void ledFlash(uchar n);
void Delay(unsigned int x);
void gotoDest(uchar target);
void setNumber(uchar n);
void setNnumber(uchar n);
void setNNnumber(uchar n);
void unsetNnumber(void);
void unsetNNnumber(void);
void IRQ_Function(void);
void motorGoGoGo(short direction);
void light(int n);
void unlight(int n);
void keyPress(int n);
void hello_LCD(uchar);

/*************************
*breif:the main function
*param:none
*return void
**************************/
void dummyOs(void)
{	
	int i;
	uchar color = 0;
	
	init();
	
	while(1)
	{
		for (i=currentLocation;i>=1 && i<=MAXF; i+=direction)
		{
			
			if (state[i] == 1)
			{
				motorGoGoGo(direction);
				
				hello_LCD(color);       //play lcd images
				color++;
				color %= 2;
				
				currentLocation += direction;
				i = currentLocation;
				setNumber(currentLocation);
				
				
				if (state[currentLocation] == 1)
				{
					state[currentLocation] = 0;
					unlight(currentLocation);
					ledFlash(2);
					
					unsetNNnumber();        //unlight next and next number
					unsetNnumber();        //unlight next number
					next = 0;
					
					if(nextnext != 0)
					{
						next = nextnext;
						setNnumber(next);
						if(cur < len)        //if has number int the queue
						{
							nextnext = nnn[cur++];   //get number from the queue
							setNNnumber(nextnext);
						}else{
							nextnext = 0;           //no number
							unsetNNnumber();
						}
					}else{
						unsetNnumber();
					}
				}
			}
		}
		
		if (i == MAXF+1)
		{
			direction = -1;
		}
		else if (i == 0)
		{
			direction = 1;
		}
	}
	
	
}

/***********************************
*brief:play images
*param - color:the background color
*return void
************************************/
void hello_LCD(uchar color)
{
	switch(color){
		case 0:
			screen_clean(0xFFFFFFFF);
			typename_Image2();
			lighton1();
			lightoff2();
			break;
		case 1:
			screen_clean(0xFFFFFFFF);
			typename_Image1();
			lighton2();
			lightoff1();
			break;
		default:
			break;
	}
}

/************************
*brief:to initialize
*param none 
*return void
************************/
void init(void)
{
	uchar i;
	
	//init step motor
	GPSR2 = 0x00060000;
 	GPCR2 = 0x00100000;
 
 	GPDR2 |= 0x00180000;	//GPIO83,GPIO84
 	GPDR1 |= 0x00200000;	//GPIO53
 	
 	led = 0xff;
 	LED_CS4 = led;
 	
 	
 	for(i = 0; i < MAXF; i++)
 	{
 		state[i] = 0;
 	}
 	currentLocation = 1;
 	direction = 1;
 	
	setNumber(1);
	unsetNnumber();   //unlight the next number
	unsetNNnumber();  //unlight the next and next number
	next = 0;
	nextnext = 0;
	len = 0;
	cur = 0;
	for(i = 0; i < 100; i++)
	{
		nnn[i] = 0;
	}
	
	hello_LCD(0);   //show the first image
}
 	
/************************
*brief:to flash the leds
*param n - the times 
*return void
************************/
void ledFlash(uchar n)
{
	uchar i;
	
	for(i=0;i<n;i++)
	{
		light(8); //亮
		Delay(50);
		unlight(8);//暗
		Delay(50);	
	}
}	

/**********************
*brief:to delay
*param x - 延时的scale
*return void
**********************/
void Delay(unsigned int x)
{
	unsigned int i, j, k;
	for (i =0; i <=x; i++)
		for (j = 0; j <0xff; j++)
			for (k = 0; k <0xff; k++);
}

/************************
*brief:到达指定楼层
*param target - 目标楼层 
*return void
************************/
void gotoDest(uchar target)
{
	uchar i;
	
	//若目标在当前楼层什么都不做
	if (target == currentLocation)
		return;
		
	//若目标在上层则往上走
	else if (target > currentLocation)
	{
	
		//逐层显示层数
		for (i=currentLocation+1; i<=target; i++)
		{
			motorGoGoGo(1);
			currentLocation = i;
			setNumber(i);
		}
		
		ledFlash(LED_FLASH_TIMES);//到达指定楼层之后闪烁LED灯
	}
	
	//若目标在下层则往下走
	else if (target < currentLocation)
	{
		for (i=currentLocation-1; i>=target; i--)
		{
			motorGoGoGo(-1);
			currentLocation = i;
			setNumber(i);
		}
		
		ledFlash(LED_FLASH_TIMES);//到达指定楼层之后闪烁LED
	}
}

/******************************
*brief:第一位八段码显示对应数字
*param n - 数字 
*return void
******************************/
void setNumber(uchar n)
{
	switch(n)
	{
		case 0:
			LED_CS1 = 0xff8f;
			break;
		case 1:
			LED_CS1 = 0xff79;
			break;
		case 2:
			LED_CS1 = 0xff24;
			break;
		case 3:
			LED_CS1 = 0xff30;
			break;
		case 4:
			LED_CS1 = 0xff19;
			break;
		case 5:
			LED_CS1 = 0xff12;
			break;
		case 6:
			LED_CS1 = 0xff02;
			break;
		default:
			break;
	}
}

/******************************
*brief:第三位八段码显示对应数字
*param n - 数字 
*return void
******************************/
void setNnumber(uchar n)
{
	switch(n)
	{
		case 0:
			LED_CS2 = 0xff8f;
			break;
		case 1:
			LED_CS2 = 0xff79;
			break;
		case 2:
			LED_CS2 = 0xff24;
			break;
		case 3:
			LED_CS2 = 0xff30;
			break;
		case 4:
			LED_CS2 = 0xff19;
			break;
		case 5:
			LED_CS2 = 0xff12;
			break;
		case 6:
			LED_CS2 = 0xff02;
			break;
		default:
			break;
	}
}

/******************************
*brief:第三位八段码灭
*param void
*return void
******************************/
void unsetNnumber(void)
{
	LED_CS2 = 0xffff;
}

/******************************
*brief:第5位八段码显示对应数字
*param n - 数字 
*return void
******************************/
void setNNnumber(uchar n)
{
	switch(n)
	{
		case 0:
			LED_CS3 = 0xff8f;
			break;
		case 1:
			LED_CS3 = 0xff79;
			break;
		case 2:
			LED_CS3 = 0xff24;
			break;
		case 3:
			LED_CS3 = 0xff30;
			break;
		case 4:
			LED_CS3 = 0xff19;
			break;
		case 5:
			LED_CS3 = 0xff12;
			break;
		case 6:
			LED_CS3 = 0xff02;
			break;
		default:
			break;
	}
}

/******************************
*brief:第五位八段码灭
*param void
*return void
******************************/
void unsetNNnumber(void)
{
	LED_CS3 = 0xffff;
}

/******************************
*brief:中断处理键盘按下那个键
*param  none 
*return void
******************************/
void IRQ_Function(void)
{	
	char i,j;
	
	i = KPDK_VALUE;					
	j = KPAS_VALUE;					

	switch (i)
	{
			
		case 0x40:					//key-press 1
			keyPress(1);
			break;
					
		case 0x02:  				//key-press 2
			keyPress(2);
			break;
					
		case 0x04:  				//key-press 3
			keyPress(3);
			break;
				
		case 0x20: 					//key-press 4
			keyPress(4);
			break;
					
		default: 
			break;
			
		
	}

	switch (j)
	{
			
		case 0x00:
			keyPress(5);			//key-press 5
			break;
					
		case 0x01:  				//key-press 6  
			break;
					
		case 0x02:  				//key-press 7
			break;
					
		case 0x05: 					//key-press 8
			break;
				
		default: 
			break;
		
	}

}

/**************************************
*brief:让步进电机转一层楼
*param direction - 1为顺时针，-1为逆时针
*return void
**************************************/
void motorGoGoGo(short direction)
{
	int j;
	int i;
	
	//设置转向，1为顺时针，0为逆时针
	if (direction == 1)
	{
		GPDR2 &= ~(0x00100000);
	}
	else
	{
		GPDR2 |= (0x00100000);
	}
	
	//让步进电机转起来，一个循环为一层楼
	for (j=0;j<100;j++)
	{	
		i = 0x00080000;
		GPSR2 |= i;
    
 		Delay(1);
    
		i = 0x00080000;
		GPCR2 = i;
    
		Delay(1);	
	}
}

/***********************************
*brief:unlight the corresponding LED
*param - n: the LED number
*return void
***********************************/
void unlight(int n)
{
	char led_value = 0x01;
	
	led_value = led_value << (n-1);
	
	led |= led_value;
	LED_CS4 = led;
}

/***********************************
*brief:light the corresponding LED
*param - n: the LED number
*return void
***********************************/
void light(int n)
{
	unsigned char led_value = 0x01;
	
	led_value = ~(led_value << (n-1));
	
	led &= led_value;
	LED_CS4 = led;
	
}

/********************************
*brief:deal with the key pressed
*param - n:the key number
*return void
********************************/
void keyPress(int n)
{
	int temp;
	
	if (n != currentLocation)
	{
		state[n] = 1;      //change the state to 1
		light(n);          //light the LED
		
		if(next == 0)
		{
			next = n;
			setNnumber(next);   //light the next number
		}else{
			if(nextnext == 0)
			{
				nextnext = n;
				
				if(nextnext == next)
				{
					return;
				}
				if(direction > 0 && currentLocation < nextnext && nextnext < next
					|| direction < 0 && currentLocation > nextnext && nextnext > next){
					temp = nextnext;
					nextnext = next;
					next = temp;
					unsetNnumber();
					setNnumber(next);
				}
				setNNnumber(nextnext);    //light the next and next number
				return;
			}else{
				nnn[len++] = n;
			}
		}
	}
}