#+TITLE:     linux系统编程
#+AUTHOR:    yuanhang zheng
#+EMAIL:     zhengyhn@gmail.com
#+DATE:      2013-02-24 Sun

* 文件与I/O
** 再来一个hello world
- 我也来写一段汇编的hello world
#+BEGIN_EXAMPLE
.data
msg:
		.ascii "yuanhang zheng\n"
		len = . - msg

.text
.global _start

_start:
		movl $len, %edx
		movl $msg, %ecx
		movl $1, %ebx     #1 is stdout
		movl $4, %eax     #4 is sys_write
		int $0x80

		movl $0, %ebx    #0 is exit code
		movl $1, %eax    #4 is sys_exit
		int $0x80
		
#+END_EXAMPLE
运行结果为：
#+BEGIN_EXAMPLE
[monkey@itlodge asm]$ as -o hello.o hello.s
[monkey@itlodge asm]$ ld -o hello hello.o
[monkey@itlodge asm]$ ./hello
yuanhang zheng
#+END_EXAMPLE
对上面程序的几点说明：
1. 汇编中.ascii定义的字符串末尾没有隐含'\0'
2. len的值是. - msg，即当前地址用.号表示，这是一种神奇的求长度方法！
- 用C语言实现刚刚的程序
#+BEGIN_SRC C -n
#include <unistd.h>

#define LEN 15

char msg[LEN] = "yuanhang zheng\n";

int main(int argc, char *argv[])
{
	write(1, msg, LEN);
	_exit(0); 
	
	return 0;
}
#+END_SRC
事实上write和_exit就包装了上面两段代码。其中头文件unistd.h意思是unix standard。
- POSIX,portable operationg system interface,用于统一各种UNIX的函数接口。
** open/close
- 在linux系统编程中，我们可以使用标准C函数库里面的fopen和fclose，也可以使用系统的
接口open/close
- open函数如下：
#+BEGIN_SRC C
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
#+END_SRC
事实上是这样声明的：
#+BEGIN_SRC C
int open(const char *pathname, int flags, ...);
#+END_SRC
flags有很多常数值选择，多个常数用按位或连接起来，这些宏定义都以O_开头（大写o），
表示or。
1. 必选项（必选一个且只能选一个）
| O_RDONLY | read only      |
|----------+----------------|
| O_WRONLY | write only     |
|----------+----------------|
| O_RDWR   | read and write |
|----------+----------------|
2. 可选项（部分）
| O_APPEND | append                                            |
|----------+---------------------------------------------------|
| O_CREAT  | create if not exist, should give parameter "mode" |
|----------+---------------------------------------------------|
| O_TRUNC  | truncate as zero byte if exist, read and write    |
|----------+---------------------------------------------------|
open与fopen的一些区别：
- 以可写的方式fopen时，如果文件不存在会自动创建，而用open必须要使用O_CREAT，否则
出错。
- 以可写的方式fopen时，如果文件已经存在则截断为0字节，而用open必须要使用O_TRUNC,
否则出错。
mode指定文件权限，这里学习到了权限字符与数字表示之间怎么计算，比如：
#+BEGIN_EXAMPLE
-rwxr-xr-x
#+END_EXAMPLE
这是一个很常见的权限，我们要把它分为3部分：
#+BEGIN_EXAMPLE
u/g/o rwx rwx rwx
#+END_EXAMPLE
记住下面的字符数字对应关系：
| u | g | o | r | w | x |
|---+---+---+---+---+---|
| 4 | 2 | 1 | 4 | 2 | 1 |
|---+---+---+---+---+---|
好，开始计算，第一个为-，表示留空，即为0。第二段为rwx，即4 + 2 + 1 = 7。
第三段和第四段为rw-，即4 + 1 = 5，最后整个权限为0755。
作者在这里提到文件权限由open的mode参数和当前进程的umask掩码共同决定。
通过下面的命令查看shell进程的umask掩码：
#+BEGIN_SRC sh
[monkey@itlodge ~]$ umask
0022
#+END_SRC
我的是0022。根据作者的推理，
- 当用touch创建一个文件时，创建权限是0666,
而touch继承了shell进程的umask掩码，变成了0666 & ~0022 = 0644。
- 当用gcc编译生成一个可执行文件时，创建权限是0777,而最后是
0777 & ~0022 = 0755
下面来做个实验，写个程序：
#+BEGIN_SRC C -n
#include <unistd.h>
#include <fcntl.h>

int main(int argc, char *argv[])
{
	int fd = open("abc.c", O_WRONLY | O_CREAT, 0666);
	close(fd);
	
	return 0;
}
#+END_SRC
运行结果为：
#+BEGIN_SRC sh
[monkey@itlodge c]$ ls -l abc.c
-rw-r--r-- 1 monkey sudo 0 Feb 24 20:15 abc.c
#+END_SRC
可以看到，权限最终为0644。
- 习题
1. 查找flags和mode参数用到的宏定义，我在fcntl-linux.h中找到如下：
#+BEGIN_SRC C
#define O_RDONLY	     00
#define O_WRONLY	     01
#define O_RDWR		     02
#ifndef O_CREAT
# define O_CREAT	   0100	/* Not fcntl.  */
#endif
#+END_SRC
以0开头，都是8进制数，而且按位或之后各自占的位不影响。
有关mode的宏则没找到。

** read/write
